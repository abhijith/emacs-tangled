-*- coding: utf-8 -*-

#+AUTHOR: icylisper
#+TITLE: Tangled Emacs Configuration

* about
This file is tangled using =org-babel-load-file=. What this does is
generate a =emacs-init.el= from the =emacs-lisp= source blocks.
* dependencies
  #+BEGIN_SRC sh
   curl -fsSL https://raw.githubusercontent.com/cask/cask/master/go | python
   sudo ln -sf ~/.cask/bin/cask /usr/local/bin/cask
   sudo apt-get install libpng-dev libz-dev libpoppler-glib-dev libpoppler-private-dev
   sudo apt-get install libgmime-2.6-0 libgmime-2.6-dev gmime-bin autoconf-archive
   sudo apt-get install xapian-tools libxapian-1.3-5
   curl https://sh.rustup.rs -sSf | sh
   export RUST_SRC_PATH=/to/rust/src
   cargo install racer
   cargo install rustfmt
   cargo install ripgrep
  #+END_SRC
* debugging
#+BEGIN_SRC emacs-lisp :tangle yes
(set-language-environment "UTF-8")
(toggle-debug-on-error nil)
(toggle-debug-on-error nil)
#+END_SRC
* el-get
#+BEGIN_SRC emacs-lisp :tangle yes
(package-initialize)
(add-to-list 'load-path "~/.emacs.d/el-get/el-get")
(add-to-list 'load-path "~/.emacs.d/el-get")
(require 'cl)
(unless (require 'el-get nil 'noerror)
  (with-current-buffer
      (url-retrieve-synchronously
       "https://raw.githubusercontent.com/dimitri/el-get/master/el-get-install.el")
    (goto-char (point-max))
    (eval-print-last-sexp)))
(add-to-list 'el-get-recipe-path "~/.emacs.d/recipes")
(add-to-list 'load-path "~/.emacs.d/el-get/elfeed")
(el-get 'sync)
#+END_SRC
* libraries
** elisp-lib
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle use-package)
(el-get-bundle s)
(el-get-bundle f)
(el-get-bundle popup)
(el-get-bundle epc)
(el-get-bundle hydra)
(el-get-bundle tablist)
(el-get-bundle alert)
(el-get-bundle ctable)
(el-get-bundle xml-plus)
(el-get-bundle esxml)
(el-get-bundle oauth2)
(use-package queue
  :ensure t)
#+END_SRC
** custom-file
#+BEGIN_SRC emacs-lisp :tangle yes
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(when (file-exists-p custom-file)
  (load custom-file))
#+END_SRC
* meta
** no-littering
keep ~/.emacs.d clean
#+BEGIN_SRC emacs-lisp :tangle yes
(setq warning-minimum-level :emergency)
(setq initial-scratch-message ";; Happy Hacking")
(el-get-bundle no-littering)
(use-package no-littering
  :init
  (require 'no-littering)
  :config
  (setq no-littering-etc-directory (expand-file-name "config/" user-emacs-directory)
	no-littering-var-directory (expand-file-name "data/" user-emacs-directory)))
#+END_SRC
** backups
#+BEGIN_SRC emacs-lisp :tangle yes
(setq backup-directory-alist '((".*" . "/tmp/"))
      auto-save-file-name-transforms '((".*" "/tmp/" t))
      backup-by-copying t
      confirm-nonexistent-file-or-buffer nil
      kept-new-versions 0
      kept-old-versions 0
      delete-old-versions t)
#+END_SRC
** keyboard
Specific Key modifiers.
#+BEGIN_SRC emacs-lisp :tangle yes
(setq ns-function-modifier 'control
      x-select-enable-clipboard t
      echo-keystrokes 0.1)
#+END_SRC
** helm
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle helm)
(use-package helm
  :init
  (create-file-buffer "*helm*")
  (helm-autoresize-mode 1)
  :config
  (add-hook 'helm-buffer-mode-hook #'(lambda () (interactive) (highline-mode 1)))
  (setq helm-mode-fuzzy-match t
	helm-semantic-fuzzy-match t
	helm-imenu-fuzzy-match t
	helm-buffers-fuzzy-matching t
	helm-recentf-fuzzy-match  nil
	helm-echo-input-in-header-line nil
	helm-mini-default-sources '(helm-source-buffers-list
				    ,(if (projectile-project-p)
					     helm-source-projectile-files-list))
	helm-bookmark-show-location nil
	helm-echo-input-in-header-line nil
	helm-ff-file-name-history-use-recentf nil
	helm-bookmark-show-location nil
	helm-autoresize-max-height 30
	helm-autoresize-min-height 20
	helm-split-window-in-side-p t
	helm-split-window-default-side 'below
	helm-display-header-line nil)
  :bind (("C-c j" . helm-imenu)
	 ("C-x b" . helm-mini)
	 ("M-y"   . helm-show-kill-ring)))

(defun filter-dired-buffers (buffer-list)
  (delq nil (mapcar
             (lambda (buffer)
               (if (eq (with-current-buffer buffer major-mode)  'dired-mode)
                   nil
                 buffer))
             buffer-list)))
(advice-add 'helm-skip-boring-buffers :filter-return 'filter-dired-buffers)

(with-eval-after-load 'helm-buffers
  (setq helm-boring-buffer-regexp-list
	'("*!dired"
	  "\\*helm-mode-switch-to-buffer*"
	  "\\*Backtrace"
	  "\\*Completions"
	  "\\*Help"
	  "\\*Shell Command Output"
	  "\\*Flycheck error message"
	  "\\*Compile-Log"
	  "\\*magit"
	  "\\*guide"
	  "\\*helm"
	  "\\*Echo"
	  "\\*code"
	  "\\*scratch"
	  "\\*Mini")))
#+END_SRC
** keybinding helper
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle emacs-helm/helm-descbinds)
(el-get-bundle guide-key)
(use-package guide-key
  :init (guide-key-mode 1)
  :config
  (progn
    (setq guide-key/idle-delay 1)
    (setq guide-key/recursive-key-sequence-flag t)
    (setq guide-key/popup-window-position 'bottom)
    (setq guide-key/guide-key-sequence
          `("C-c" "C-x" "C-M" "C-c p" "C-h"))))
#+END_SRC
* window
** no-bells-and-whistles
Disable all fancy windowing components
#+BEGIN_SRC emacs-lisp :tangle yes
(tooltip-mode -1)
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
(mouse-wheel-mode t)
(blink-cursor-mode 0)
(defalias 'yes-or-no-p 'y-or-n-p)
(setq frame-title-format '(buffer-file-name "%f" ("%b"))
      inhibit-startup-message t
      inhibit-startup-screen t
      resize-mini-windows nil
      ring-bell-function 'ignore
      use-dialog-box nil
      visible-bell nil)
#+END_SRC
** theme
#+BEGIN_SRC emacs-lisp :tangle yes
(add-to-list 'custom-theme-load-path "~/.emacs.d/themes")
(add-to-list 'load-path "~/.emacs.d/themes")
(add-to-list 'custom-theme-load-path "~/.emacs.d/el-get/dusk-theme")
(el-get-bundle dusk-theme)
(cond
 ((equal (system-name) "mint")
  (progn
    (set-frame-font "Inconsolata 14" nil t)
    (setq font-lock-maximum-decoration t)
    (load-theme 'charcoal-black t)))
 ((equal (system-name) "hodor")
  (progn
    (set-frame-font "Inconsolata 14" nil t)
    (setq font-lock-maximum-decoration t)
    (load-theme 'charcoal-black t)))
 (t (load-theme 'dusk t)))
#+END_SRC
** ace-window
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle ace-window)
(use-package ace-window
  :config
  (bind-key "M-p" 'ace-window))
#+END_SRC
** windmove
| shift-<left/right> | windmove |
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package windmove
  :config
  (windmove-default-keybindings 'shift)
  (setq windmove-wrap-around t)
  (bind-key [S-right] 'windmove-right)
  (bind-key [S-left]  'windmove-left)
  (bind-key [S-up] 'windmove-up)
  (bind-key [S-down]  'windmove-down))
#+END_SRC
** perspective
Workspaces using perspective
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle perspective)
(use-package perspective
  :init
  (persp-mode)
  :config
  (setq persp-modestring-dividers '("(" ")" "|")
	persp-mode-prefix-key (kbd "s-x"))
  (bind-key [s-c] 'persp-switch)
  (bind-key [s-right] 'persp-next)
  (bind-key [s-left] 'persp-prev))
#+END_SRC
* buffer
** prog-defaults
#+BEGIN_SRC emacs-lisp :tangle yes
(setq fill-column 80
      next-line-add-newlines nil
      require-final-newline nil
      truncate-partial-width-windows nil
      sentence-end-double-space nil
      indent-tabs-mode nil
      enable-local-variables nil)
(add-hook 'prog-mode-hook
	  (lambda ()
	    (font-lock-add-keywords
	     nil '(("\\<\\(FIX\\|TODO\\|FIXME\\|HACK\\|REFACTOR\\):"
		    1 font-lock-warning-face t)))))
(auto-revert-mode 1)
(add-hook 'after-save-hook
	  'executable-make-buffer-file-executable-if-script-p)
(global-set-key (kbd "C-x k") 'kill-this-buffer)
#+END_SRC
** undo-tree
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle undo-tree)
(use-package undo-tree
  :init (global-undo-tree-mode)
  :config (setq
	   undo-tree-visualizer-diff t
	   undo-tree-visualizer-timestamps t))
#+END_SRC
** goto-line
#+BEGIN_SRC emacs-lisp :tangle yes
(defun goto-line-with-feedback ()
  "Show line numbers temporarily, while prompting for the line number input"
  (interactive)
  (unwind-protect
      (progn
        (linum-mode 1)
        (goto-line (read-number "Goto line: ")))
    (linum-mode -1)))
(global-set-key [remap goto-line] 'goto-line-with-feedback)
#+END_SRC
** highline
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle highline)
(global-set-key (kbd "C-h C-i") 'highline-mode)
#+END_SRC
** swoop
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle helm-swoop)
(use-package helm-swoop
  :init
  (bind-key "C-c s" 'helm-swoop))
#+END_SRC
** swap-buffers
#+BEGIN_SRC emacs-lisp :tangle yes
(defun swap-buffers ()
  "Put the buffer from the selected window in next window, and vice versa."
  (interactive)
  (let* ((this (selected-window))
         (other (next-window))
         (this-buffer (window-buffer this))
         (other-buffer (window-buffer other)))
    (set-window-buffer other this-buffer)
    (set-window-buffer this other-buffer)))
#+END_SRC
** adaptive-wrap
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle adaptive-wrap)
#+END_SRC
** crux
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle crux)
(use-package crux
  :bind (("C-a" . crux-move-beginning-of-line)))
#+END_SRC
** indent-buffer
#+BEGIN_SRC emacs-lisp :tangle yes
(defun indent-buffer ()
  (interactive)
  (indent-region (point-min) (point-max)))
#+END_SRC
** minibuffer
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle smex)

(defun smex-update-after-load (unused)
  (when (boundp 'smex-cache)
    (smex-update)))

(use-package smex
  :init
  (add-hook 'after-load-functions 'smex-update-after-load)
  :bind (("M-z" . smex)))

(define-key minibuffer-local-completion-map '[tab] 'minibuffer-complete)
(define-key minibuffer-local-completion-map '[spc] 'minibuffer-complete-word)
(define-key minibuffer-local-must-match-map '[tab] 'minibuffer-complete)
(define-key minibuffer-local-must-match-map '[spc] 'minibuffer-complete-word)
#+END_SRC
* dired
** wdired
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle wdired)
(use-package wdired
  :bind (:map dired-mode-map
	      ("r" . wdired-change-to-wdired-mode))
  :config
  (setq directory-sep-char ?/)
  (add-hook 'dired-load-hook
	    (lambda ()
	      (load "dired-x")
	      (setq directory-sep-char ?/
		    wdired-allow-to-change-permissions t
		    dired-backup-overwrite t)))
  (add-hook 'dired-mode-hook #'highline-mode-on))
#+END_SRC
** dired-narrow
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package dired-narrow
  :bind (:map dired-mode-map
	      ("/" . dired-narrow)))
#+END_SRC
** dired-subtree
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle dired-hacks)
(use-package dired-subtree
  :bind (:map dired-mode-map
	      ("<tab>" . dired-subtree-cycle)
	      ("i" . dired-subtree-insert)
	      ("k" . dired-subtree-remove))
  :config
  (setq dired-subtree-line-prefix
	(lambda (depth) (make-string (* 2 depth) ?\s)))
  (setq dired-subtree-use-backgrounds nil))
#+END_SRC
** dired-details
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle dired-details)
(use-package dired-details
  :init
  (dired-details-install)
  :config
  (bind-key (kbd "C-x C-d") 'dired)
  (setq dired-details-hidden-string ""
	dired-dwim-target t))
#+END_SRC
** dired-lynx
#+BEGIN_SRC emacs-lisp :tangle yes
(defun dired-lynx-keybindings ()
  (define-key dired-mode-map [left]  'dired-up-directory)
  (define-key dired-mode-map [right] 'dired-view-file))
(add-hook 'dired-mode-hook 'dired-lynx-keybindings)
(add-hook 'dired-mode-hook #'highline-mode-on)
#+END_SRC
** dired-x
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package dired-x
  :bind (:map dired-mode-map
	      ("o" . dired-open-file)
	      ("[C-return]" . dired-open-file))
  :config
  (setq-default dired-omit-files-p nil)
  (setq dired-omit-files (concat dired-omit-files "\\|^\\..+$|^\\.?#")
        dired-omit-mode t)
  (add-hook 'dired-after-readin-hook #'highline-mode-on)
  (add-hook 'dired-mode-hook #'highline-mode-on))
#+END_SRC
** dired-kill
#+BEGIN_SRC emacs-lisp :tangle yes
(defun dired-kill-buffers ()
  (interactive)
  (mapc (lambda (buffer)
          (when (eq 'dired-mode (buffer-local-value 'major-mode buffer))
            (kill-buffer buffer)))
        (buffer-list)))
#+END_SRC
** dired-ranger
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package dired-ranger
  :bind (:map dired-mode-map
	      ("W" . dired-ranger-copy)
	      ("X" . dired-ranger-move)
	      ("Y" . dired-ranger-paste)))
#+END_SRC
* format
Various file formats and extensions
** json
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle js2-mode)
(el-get-bundle ljos/jq-mode)
(use-package jq-mode
  :init
  (autoload 'jq-mode "jq-mode.el" "Major mode for editing jq files" t)
  :config
  (add-to-list 'auto-mode-alist '("\\.jq$" . jq-mode))
  (with-eval-after-load "json-mode"
    (define-key json-mode-map (kbd "C-c C-j") #'jq-interactively)))
#+END_SRC
** toml
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle toml-mode)
#+END_SRC
** epub
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle nov)
(el-get-bundle justify-kp)
(use-package nov
  :init
  (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
  :config
  (setq visual-fill-column-center-text t))
#+END_SRC
** md
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle markdown-mode)
#+END_SRC
** dot
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle graphviz-dot-mode)
#+END_SRC
** yaml
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle yaml-mode)
#+END_SRC
** pu
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle plantuml-mode)
(defun plantuml-display-image ()
  (interactive)
  (let* ((plantuml-file (concat (file-name-sans-extension buffer-file-name) ".png"))
         (plantuml-buf (get-buffer (file-name-nondirectory plantuml-file))))
    (if (not (buffer-live-p plantuml-buf))
	(find-file plantuml-file)
      (progn
	(pop-to-buffer plantuml-buf)
	(revert-buffer nil t nil)))))
#+END_SRC
* lisp
** paredit
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle paredit)
(use-package paredit
  :bind (("M-]" . paredit-forward-slurp-sexp)
	 ("M-[" . paredit-backward-slurp-sexp)
	 ("M-}" . paredit-forward-barf-sexp)
	 ("M-{" . paredit-backward-barf-sexp))
  :init
  (add-hook 'emacs-lisp-mode-hook 'paredit-mode)
  (add-hook 'cider-repl-mode-hook 'paredit-mode)
  (add-hook 'clojure-mode-hook 'paredit-mode)
  (add-hook 'lisp-mode-hook 'paredit-mode)
  (add-hook 'slime-mode-hook 'paredit-mode)
  (add-hook 'scheme-mode-hook 'paredit-mode))
#+END_SRC
** rainbow-delimiters
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle rainbow-delimiters)
(use-package rainbow-delimiters
  :init
  (require 'rainbow-delimiters nil)
  :config
  (add-hook 'emacs-lisp-mode-hook 'rainbow-delimiters-mode)
  (add-hook 'lisp-mode-hook 'rainbow-delimiters-mode)
  (add-hook 'scheme-mode-hook 'rainbow-delimiters-mode)
  (add-hook 'clojure-mode-hook 'rainbow-delimiters-mode)
  (show-paren-mode 1))
#+END_SRC

#+RESULTS:
: t

** slime
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
(use-package lisp-mode
  :mode ("\\.lisp$" "\\.cl$" "stumpwmrc"))

(el-get-bundle slime)
(use-package slime
  :commands (slime slime-lisp-mode-hook)
  :config
  (add-to-list 'slime-contribs 'slime-fancy)
  (slime-setup '(slime-asdf slime-banner slime-fuzzy))
  (add-hook 'lisp-mode-hook 'slime-mode)
  (add-hook 'slime-repl-mode-hook 'paredit-mode)
  (setq inferior-lisp-program "/usr/local/bin/sbcl --dynamic-space-size 1024"
	slime-net-encoding-system 'utf-8-unix
	slime-complete-symbol-function 'slime-fuzzy-complete-symbol
	slime-startup-animation t))
#+END_SRC
** ielm
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ielm
  :defer t
  :config
  (progn
    (define-key ielm-map (kbd "C-c C-z") #'quit-window)))
#+END_SRC
** pretty-symbols
#+BEGIN_SRC emacs-lisp :tangle yes
(global-prettify-symbols-mode 1)
(setq prettify-symbols-unprettify-at-point t)
#+END_SRC
** clojure-mode
(el-get-bundle clojure-mode)
(el-get-bundle edn)
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package clojure-mode
  :mode ("\\.edn$" "\\.clj[sx]?$" "Irminfile" "\\.boot$")
  :config
  (add-hook 'clojure-mode-hook
	    (lambda ()
	      (push '("fn" . ?λ) prettify-symbols-alist)))
  (setq clojure-align-forms-automatically t
	comment-column 70)
  (define-clojure-indent
    (defroutes 'defun)
    (GET 2)
    (POST 2)
    (PUT 2)
    (DELETE 2)
    (HEAD 2)
    (ANY 2)
    (context 2)))
#+END_SRC
** cider
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle clojure-emacs/cider :checkout "v0.15.0")
(el-get-bundle clojure-emacs/helm-cider)
(use-package cider
  :init
  (setq nrepl-hide-special-buffers nil
	nrepl-buffer-name-show-port t
	nrepl-buffer-name-separator "-"
	nrepl-popup-stacktraces-in-repl nil
	nrepl-log-messages nil
	cider-repl-display-help-banner nil
	cider-interactive-eval-result-prefix "=> "
     	cider-repl-use-clojure-font-lock t
	cider-repl-tab-command #'indent-for-tab-command
	cider-repl-pop-to-buffer-on-connect nil
	cider-repl-history-size 1000
	cider-repl-history-file "~/.emacs.d/var/cider.txt"
	cider-repl-result-prefix "=> "
	cider-repl-display-in-current-window t
	cider-repl-wrap-history nil
	cider-repl-use-pretty-printing t
	cider-lein-parameters "trampoline repl :headless"
	cider-show-error-buffer t
	cider-auto-select-error-buffer t
	cider-stacktrace-fill-column 80
	cider-stacktrace-default-filters '(tooling dup)
	cider-test-show-report-on-success t
	cider-prompt-save-file-on-load nil
	cider-prompt-for-symbol nil
	cider-switch-to-repl-command 'cider-switch-to-current-repl-buffer
	cider-font-lock-dynamically nil
	cider-popup-stacktraces t
	cider-test-items-background-color "Grey15"
	cider-stacktrace-frames-background-color "Grey15"
	cider-test-show-report-on-success t)
  (add-hook 'cider-repl-mode-hook #'eldoc-mode)
  (add-hook 'nrepl-interaction-mode-hook 'nrepl-turn-on-eldoc-mode)
  (add-hook 'cider-repl-mode-hook 'rainbow-delimiters-mode)
  :bind (("C-c n"  . cider-find-ns)
	 ("C-c e"  . cider-visit-error-buffer)
	 ("C-c h"  . cider-apropos)
	 ("C-c M-c". cider-connect)
	 :map cider-repl-mode-map
	 ("C-l"    . cider-repl-clear-buffer)
	 ("M-p"    . cider-repl-previous-input)))

(add-to-list 'load-path "~/.emacs.d/el-get/helm-cider")
(use-package helm-cider
  :init
  (require 'helm-cider-spec)
  (load "helm-cider-repl.el")
  (add-hook 'cider-repl-mode-hook 'helm-cider-mode)
  (add-hook 'clojure-mode-hook 'helm-cider-mode))

(defadvice clojure-test-run-tests (before save-first activate)
  (save-buffer))
(defadvice nrepl-load-current-buffer (before save-first activate)
  (save-buffer))
#+END_SRC
** lein
#+BEGIN_SRC emacs-lisp :tangle yes
(defun lein-test ()
  (interactive)
  (compile "lein test")
  (pop-to-buffer
   (get-buffer "*compilation*"))
  (rename-buffer "*lein-test*")
  (delete-window))

(defun lein-run ()
  (interactive)
  (compile "lein run")
  (pop-to-buffer
   (get-buffer "*compilation*"))
  (rename-buffer "*lein-run*")
  (delete-window))
#+END_SRC
** racket-mode
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle racket-mode)
(use-package racket-mode
  :config
    (add-hook 'racket-mode-hook
        (lambda ()
          (push '("lambda" . ?λ) prettify-symbols-alist)))
    (setq racket-program "/usr/local/bin/racket"
	  racket-images-inline t
	  tab-always-indent 'complete
	  comint-prompt-read-only t)
  (add-hook 'scheme-mode-hook 'racket-mode)
  (add-hook 'racket-mode-hook #'enable-paredit-mode)
  (add-hook 'racket-mode-hook 'rainbow-delimiters-mode)
  (add-hook 'racket-repl-mode-hook #'enable-paredit-mode)
  (add-hook 'racket-repl-mode-hook 'rainbow-delimiters-mode))
#+END_SRC
** emacs-lisp
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package emacs-lisp-mode
  :init
  (progn
    (use-package eldoc
      :init (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode))
    (use-package macrostep
      :bind ("C-c e" . macrostep-expand))
    (use-package ert
      :config (add-to-list 'emacs-lisp-mode-hook 'ert--activate-font-lock-keywords)))
  :config
  (progn
    (setq tab-always-indent 'complete)
    (add-to-list 'completion-styles 'initials t))
  :bind (("M-." . find-function-at-point)
         ("M-&" . complete-symbol))
  :interpreter (("emacs" . emacs-lisp-mode)))
#+END_SRC
* media
** emms
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle emms)
(use-package emms
  :config
  (add-to-list 'emms-player-base-format-list "opus")
  (emms-all)
  (emms-default-players)
  (setq emms-source-file-default-directory "~/src/music/"
	emms-player-mplayer-parameters '("-slave" "-quiet" "-really-quiet" "-vo" "null")
	emms-playlist-default-major-mode 'emms-playlist-mode)
  (global-set-key '[C-c space] 'emms-pause))
#+END_SRC
** eimp
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle eimp)
(use-package eimp
  :config
  (add-hook 'image-mode-hook 'eimp-mode))
#+END_SRC
** festival
* modeline
** smart-mode-line
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle smart-mode-line)
(use-package smart-mode-line
  :init
  (sml/setup)
  (setq sml/no-confirm-load-theme t
	sml/vc-mode-show-backend t
	;sml/mode-width 10
	;sml/name-width 20
	resize-mini-windows nil)
  (sml/apply-theme nil)
  :config
  (dolist (m '("Helm" "AC" "Undo-Tree" "ARev" "Anzu" "Guide" "company"))
    (add-to-list 'sml/hidden-modes (concat " " m))))
#+END_SRC
** time
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package time
  :config
  (display-time-mode)
  (setq
   display-time-day-and-date nil
   display-time-24hr-format t
   display-time-default-load-average nil))
#+END_SRC
** battery
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package battery
  :config
  (display-battery-mode))
#+END_SRC
* org
** org-mode
- author
  Carsten Dominik
- items
  | TAB       | org-cycle            |
  | S-TAB     | org-shiftab          |
  | M-left    | org-do-promote       |
  | M-right   | org-do-demote        |
  | S-M-left  | org-promote-subtree  |
  | S-M-right | org-demote-subtee    |
  | C-c C-c   | org-ctrl-c-ctrl-c    |
  | M-ret     | new-list-item        |
  | M-S-ret   | new-checkbox-item    |
  | C-c -     | cycle-item           |
  | C-c /     | org-sparse-tree      |
  | C-c C-l   | org-insert-link      |
  | C-c C-o   | org-open-link        |
  | C-c C-q   | org-set-tags-command |
  | C-C C-c   | org-set-tags-command |
  | C-c C-x p | org-set-property     |
- timers
  | C-c -     | cycle-item     |
  | C-c C-x - | org-timer-item |
  | M-ret     | insert-heading |
  | C-c C-x . | stop timer     |
- agenda
  | C-c c   | org-capture        |
  | C-c a   | org-agenda-list    |
  | C-c C-s | org-schedule       |
  | C-c C-d | org-deadline       |
  | :       | org-set-tag        |
  | v m     | monthly view       |
  | t       | org-set-todo-state |
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
(use-package org
  :mode ("\\.org\\'" . org-mode)
  :bind (:map org-mode-map
	 ("C-c l" . org-store-link)
	 ("C-c c" . org-capture)
	 ("C-c b" . org-iswitchb)
	 ("C-c C-w" . org-refile)
	 ("C-c C-x C-o" . org-clock-out)
	 ("M-o" . ace-link-org))
  :config
  (bind-key "C-c a" 'org-agenda)
  (bind-key "C-c c" 'org-capture)
  (progn
    (setq org-directory "~/src/org"
	  org-mode-file-dir "~/src/org")
    (setq org-tags-column 80
	  org-hide-emphasis-markers t
	  org-hide-leading-stars t
	  org-startup-indented t
	  org-replace-disputed-keys nil
	  org-support-shift-select 'always
	  org-use-speed-commands t
	  org-refile-targets '((nil :level . 1)
			       (org-agenda-files :level . 1))
	  org-log-done 'time
	  org-html-doctype "html5"
	  org-agenda-include-diary nil
	  org-todo-keywords '((sequence "TODO(t)"
					"|"
					"NOW(n)"
					"DONE(d)"))
	  org-M-RET-may-split-line '((item . nil))
	  org-return-follows-link t)
    (setq  org-use-fast-todo-selection t
	   org-agenda-window-setup '(current-window-configuration)
	   org-deadline-warning-days 14
	   org-agenda-files '("~/src/org/todo.org")
	   org-highest-priority ?A
	   org-lowest-priority ?C
	   org-default-priority ?A
	   org-todo-keywords '((sequencep "TODO(t)"
					  "|"
					  "NOW(n)"
					  "DONE(d)")))

    (add-hook 'org-mode-hook 'turn-on-font-lock)
    (add-hook 'org-mode-hook 'org-indent-mode)
    (add-hook 'org-mode-hook 'auto-fill-mode)
    (add-hook 'org-agenda-mode-hook 'highline-mode-on)

    (add-hook 'before-save-hook 'org-align-all-tags nil t)
    (define-key org-mode-map [S-right] 'windmove-right)
    (define-key org-mode-map [S-left]  'windmove-left)
    (define-key org-mode-map [S-up] 'windmove-up)
    (define-key org-mode-map [S-down]  'windmove-down)
    (define-key org-agenda-mode-map [S-right] 'windmove-right)
    (define-key org-agenda-mode-map [S-left]  'windmove-left)
    (define-key org-agenda-mode-map [S-up] 'windmove-up)
    (define-key org-agenda-mode-map [S-down]  'windmove-down)))
#+END_SRC

#+RESULTS:

** org-babel
| C-c C-v   | org-bable prefix |
| C-c C-v t | org-bable-tangle |
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle ob-restclient)
(el-get-bundle ob-rust)
(el-get-bundle restclient)
(use-package ob
  :init
  (require 'ob)
  (require 'cider)
  :config
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (ditaa . t)
     (sh . t)
     (org . t)
     (sql . t)
     (sh . t)
     (ditaa . t)
     (plantuml . t)
     (clojure . t)
     (dot . t)
     (rust . t)
     (restclient . t)))
  (setq org-babel-clojure-backend 'cider
	org-babel-clojure-sync-nrepl-timeout nil
	org-confirm-babel-evaluate nil
	org-plantuml-jar-path "~/.emacs.d/el-get/plantuml-mode/plantuml.jar"
	org-inline-image-overlays t
	org-babel-default-header-args:clojure '((:results . "silent") (:tangle . "yes"))
	org-startup-with-inline-images t)
  (add-hook 'org-babel-after-execute-hook
	    (lambda ()
	      (when org-inline-image-overlays
		(org-redisplay-inline-images))))
  (add-to-list 'org-babel-tangle-lang-exts '("clojure" . "clj")))

(use-package org-src
  :config
    (setq org-src-fontify-natively t
	  org-src-tab-acts-natively t
	  org-src-window-setup 'current-window
	  org-src-preserve-indentation t
	  org-edit-src-content-indentation 0
	  org-inline-image-overlays t))
#+END_SRC
** org-present
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle org-present)
(use-package org-present
  :config
  (progn
    (add-hook 'org-present-mode-hook
	      (lambda ()
		(org-present-big)
		(org-display-inline-images)
		(org-present-hide-cursor)
		(org-present-read-only)))
    (add-hook 'org-present-mode-quit-hook
	      (lambda ()
		(org-present-small)
		(org-remove-inline-images)
		(org-present-show-cursor)
		(org-present-read-write)))))
#+END_SRC
** org-rifle
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle helm-org-rifle)
(use-package helm-org-rifle
  :config
  (bind-key "C-x g" (lambda ()
		      (interactive)
		      (helm-org-rifle-directories '("~/src/org")))))
#+END_SRC
** org-crypt
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package org-crypt
  :config
  (progn
    (org-crypt-use-before-save-magic)
    (setq org-tags-exclude-from-inheritence '("crypt")
	  org-crypt-key nil)))
#+END_SRC
** org-passwords
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle org-passwords)
(use-package org-passwords
  :config
  (setq org-passwords-file "~/src/org/passwords.org"))
#+END_SRC
** org-gcal
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle org-gcal)
#+END_SRC
** org-links
#+BEGIN_SRC emacs-lisp
(el-get-bundle org-pdfview)
(el-get-bundle org-ebook)
(add-to-list 'org-file-apps
	     '(("\\.pdf\\'" . (lambda (file link) (org-pdfview-open link)))
	       ("\\.epub\\'" . (lambda (file link) (org-ebook-open link)))))
(add-hook 'pdf-view-mode-hook #'(lambda () (require 'org-pdfview)))
#+END_SRC
** org-preview
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
(el-get-bundle org-preview-html)
(use-package org-preview-html
  :bind (:map org-mode-map
	      ("C-c C-e" . org-preview-html/preview))
  :config
  (setq org-preview-html/htmlfilename (concat "/tmp/" (make-temp-name "-") ".html")))

#+END_SRC

* project
** vc
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package vc
  :config
  (setq vc-mistrust-permissions t
	version-control t
        vc-initial-comment t
        vc-consult-headers nil
        vc-make-backup-files t))
#+END_SRC
** projectile
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle projectile)
(el-get-bundle helm-projectile)
(use-package helm-projectile)
(use-package projectile
  :init
  (projectile-global-mode)
  (helm-projectile-on)
  :defer (projectile-cleanup-known-projects)
  :diminish projectile-mode
  :config
  (setq projectile-switch-project-action 'helm-projectile
	projectile-find-dir-includes-top-level t
	projectile-remember-window-configs t
	projectile-keymap-prefix (kbd "C-c p")
	projectile-completion-system 'helm
	projectile-indexing-method 'alien
	projectile-enable-caching t
	projectile-require-project-root t
	projectile-mode-line '(:eval (format " (%s)" (projectile-project-name)))
	projectile-sort-order 'modification-time)
  (if (eq window-system 'x)
      (shell-command "xmodmap -e 'clear Lock' -e 'keycode 66 = F13'"))
  (bind-key [f13] 'projectile-switch-project)
  :bind (("C-c f" . helm-projectile-find-file)
  	 ("C-c D" . projectile-dired)
         ("C-c !" . projectile-run-command-in-root)
	 ("C-c RET" . projectile-run-shell)
	 ("C-x RET" . projectile-run-shell)
         ("C-c t" . projectile-find-test-file)
  	 ("C-c b" . helm-projectile-switch-to-buffer)
	 ("C-x p" . projectile-switch-project)))
#+END_SRC
** helm-git-grep
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle helm-git-grep)
(el-get-bundle wgrep)
(use-package helm-git-grep
  :init
  (require 'helm-git-grep)
  (global-set-key (kbd "C-c g") 'helm-git-grep)
  (define-key isearch-mode-map (kbd "C-c g") 'helm-git-grep-from-isearch)
  (eval-after-load 'helm
    '(define-key helm-map (kbd "C-c g") 'helm-git-grep-from-helm)))
#+END_SRC
** ripgrep
#+BEGIN_SRC emacs-lisp tangle :yes
(el-get-bundle rg)
(use-package rg
  :config
  (bind-key "C-c r" 'rg-project))
#+END_SRC
** ffip
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle find-file-in-project)
(defun ffip-create-pattern-file-finder (&rest patterns)
  (lexical-let ((patterns patterns))
    (lambda ()
      (interactive)
      (let ((ffip-patterns patterns))
        (find-file-in-project)))))
(use-package find-file-in-project
  :config
  (setq  helm-ff-skip-boring-files t
	 helm-ff-search-library-in-sexp nil
	 helm-ff-file-name-history-use-recentf nil)
  (bind-key "C-c q" (ffip-create-pattern-file-finder "*.clj")))
#+END_SRC
** git-modeline
** diff-hl
** magit
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle magit)
(el-get-bundle gh)
(use-package magit
  :init
  (progn
    (require 'gh)
    (require 'gh-users)
    (add-to-list 'auto-mode-alist '("COMMIT_EDITMSG$" . diff-mode)))
  :config
  (setq magit-auto-revert-mode 1
	magit-last-seen-setup-instructions "1.4.0"
	diff-switches "-u"
	magit-push-always-verify nil
	magit-git-executable "git"
	magit-save-repository-buffers 'dontask
	magit-default-tracking-name-function #'magit-default-tracking-name-branch-only)
  (add-hook 'magit-mode-hook #'highline-mode-on)
  :bind
  (("C-c m" . magit-status)
   ("C-c l" . magit-log-buffer-file)
   ("C-c L" . magit-log-head)
   ("C-c o" . magit-checkout)
   ("C-c d" . magit-diff-buffer-file)
   ("C-c D" . magit-diff)))

(defun magit-ignore-whitespace ()
  "Ignore whitespace."
  (interactive)
  (add-to-list 'magit-diff-options "-w")
  (magit-refresh))

(defun magit-dont-ignore-whitespace ()
  "Don't ignore whitespace."
  (interactive)
  (setq magit-diff-options (remove "-w" magit-diff-options))
  (magit-refresh))

(defun magit-toggle-whitespace ()
  "Toggle whitespace."
  (interactive)
  (if (member "-w" magit-diff-options)
      (magit-dont-ignore-whitespace)
    (magit-ignore-whitespace)))
#+END_SRC
** magit-filenotify
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle magit-filenotify)
(use-package magit-filenotify
  :config
  (add-hook 'magit-status-mode-hook 'magit-filenotify-mode))
#+END_SRC
** github
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle gist)
(use-package gist
  :ensure t
  :init
  (defun send-to-gist (answer)
    (interactive "cSend region to Gist?: (y/n) ")
    (if (equal answer ?\y) (gist-region (region-beginning) (region-end)))))

(el-get-bundle git-link)
(el-get-bundle github-browse-file)
(el-get-bundle github-clone)
(el-get-bundle helm-open-github)
#+END_SRC
** circleci
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle circleci)
(use-package circleci
  :init
  (autoload 'circleci "circleci" "Show CI build output" t))
#+END_SRC
* rust
** rust-mode
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle rust-mode)
(use-package rust-mode
  :mode ("\\.rs$" . rust-mode)
  :config
  (progn
    (setq rust-format-on-save t)
    (add-hook 'rust-mode-hook
	      (lambda ()
		(local-set-key (kbd "C-c <tab>") 'rust-format-buffer)))))
#+END_SRC
** flycheck-rust
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle flycheck-rust)
(use-package flycheck-rust
  :config
  (add-hook 'flycheck-mode-hook #'flycheck-rust-setup))
#+END_SRC
** cargo
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle cargo)
(use-package cargo
  :config
  (add-hook 'rust-mode-hook 'cargo-minor-mode)
  (setq compile-command "cargo build"))
#+END_SRC
** racer-mode
#+BEGIN_SRC emacs-lisp :tangle yes
(when (getenv "RUST_SRC_PATH")
  (el-get-bundle rust-racer)
  (el-get-bundle emacs-racer)
  (use-package racer-mode
    :config
    (setq racer-rust-src-path (getenv "RUST_SRC_PATH"))
    (add-hook 'rust-mode-hook #'racer-mode)
    (add-hook 'racer-mode-hook #'flycheck-mode)
    (add-hook 'racer-mode-hook #'eldoc-mode)
    (add-hook 'racer-mode-hook #'cargo-minor-mode)))
#+END_SRC
* system
** comint
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package comint
  :defer t
  :config
  (progn
    (setf comint-prompt-read-only t
          comint-history-isearch nil)
    (add-hook 'shell-mode-hook
          (lambda ()
	    (define-key shell-mode-map (kbd "C-r") 'helm-comint-input-ring)
	    (define-key shell-mode-map (kbd "M-r") 'helm-comint-input-ring)
            (define-key shell-mode-map (kbd "C-l") 'comint-clear-buffer)))))
(add-to-list 'exec-path "/usr/local/bin")

(use-package shell
  :config
  (progn
    (setq explicit-shell-file-name "bash")))
#+END_SRC
** eshell
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package eshell
  :bind ("M-e" . eshell)
  :init
  (add-hook 'eshell-first-time-mode-hook
            (lambda ()
              (add-to-list 'eshell-visual-commands "htop")))
  :config
  (progn
    (setq eshell-history-size 5000)
    (setq eshell-save-history-on-exit t)))
#+END_SRC
** bash-completion
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle bash-completion)
(use-package bash-completion
  :disabled t
  :init
  (bash-completion-setup))
#+END_SRC
** shell-pop
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle shell-pop)
#+END_SRC
** docker
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle docker)
(el-get-bundle dockerfile-mode)
(use-package docker
  :config
  (add-hook 'docker-containers-mode #'highline-mode-on))
#+END_SRC
** sudo
#+BEGIN_SRC emacs-lisp :tangle yes
(defun sudo-find-file (file-name)
  (interactive "Fsudo find file: ")
  (let ((tramp-file-name (concat "/sudo::" (expand-file-name file-name))))
    (find-file tramp-file-name)))

(global-set-key (kbd "C-x F") 'sudo-find-file)
#+END_SRC
** proced
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package proced
  :config
  (setq proced-auto-update-flag t))
#+END_SRC
** ssh
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle ssh)
(el-get-bundle ssh-config)
(use-package ssh
  :init
  (add-hook 'ssh-mode-hook
	    (lambda ()
	      (setq ssh-directory-tracking-mode t)
	      (shell-dirtrack-mode t)
	      (setq dirtrackp nil))))
#+END_SRC
** helm-sys
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package helm-sys)
#+END_SRC
** tramp
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package tramp
  :config
  (setq tramp-default-method "ssh"
	tramp-auto-save-directory "~/.emacs.d/tramp-autosave-dir"
	password-cache-expiry 3600
	tramp-ssh-controlmaster-options  (concat
					  "-o ControlPath=/tmp/ssh-ControlPath-%%r@%%h:%%p "
					  "-o ControlMaster=auto -o ControlPersist=no"))
  (progn
    (add-to-list 'tramp-default-proxies-alist
		 '(nil "\\`root\\'" "/ssh:%h:"))
    (add-to-list 'tramp-default-proxies-alist
		  '((regexp-quote (system-name)) nil nil))))

#+END_SRC
* web
** eww
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle eww-lnum)
(el-get-bundle ace-link)
(use-package eww
  :bind
  (:map eww-mode-map
   ("C-x g" . eww)
   ("C-x G" . eww-browse-with-external-browser)
   ("s-h" . eww-list-histories))
  :config
  (setq  eww-search-prefix  "https://www.google.com/search?q="
	 eww-download-directory "~/downloads"
	 eww-form-checkbox-symbol "[ ]"
	 eww-form-checkbox-selected-symbol "[X]"
	 shr-color-visible-luminance-min 80)
    (add-hook 'eww-mode 'ace-link-mode))

(use-package eww-lnum
  :bind (:map eww-mode-map
	      ("f" . eww-lnum-follow)
	      ("U" . eww-lnum-universal)))

(defun eww-browse-url-of-file ()
  "Browse the current file using `eww'."
  (interactive)
  (let ((browse-url-browser-function 'eww-browse-url))
    (call-interactively #'browse-url-of-file)))
#+END_SRC
** elfeed
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle elfeed)
(el-get-bundle elfeed-org)
(defvar elfeed-show-switch-function #'switch-to-buffer)
(defun elfeed-show-find-window ()
  (cl-loop for window in (window-list)
           for buffer = (window-buffer window)
           for mode = (with-current-buffer buffer major-mode)
           when (eq mode 'elfeed-show-mode)
           return window))

(defun elfeed-show-in-other-buffer (buffer)
  (let ((target (elfeed-show-find-window)))
    (if target
        (setf (window-buffer target) buffer)
      (pop-to-buffer buffer))))

(defun switch-to-elfeed-entry-buffer ()
  (interactive)
  (let ((entry "*elfeed-entry*"))
    (if (eq (current-buffer) (get-buffer entry))
	(switch-to-buffer "*elfeed-search*")
      (if (get-buffer entry)
	  (switch-to-buffer "*elfeed-entry*")
	(elfeed)))))

(defhydra hydra-elfeed ()
  "filter"
  ("c" (elfeed-search-set-filter "@50-weeks-ago +clojure") "clojure")
  ("e" (elfeed-search-set-filter "@50-weeks-ago +emacs") "emacs")
  ("l" (elfeed-search-set-filter "@10-weeks-ago +lisp") "lisp")
  ("t" (elfeed-search-set-filter "@10-weeks-ago +tech") "tech")
  ("a" (elfeed-search-set-filter "@4-weeks-ago +atlantic") "atlantic")
  ("s" (elfeed-search-set-filter "@4-weeks-ago +stallman") "stallman")
  ("r" (elfeed-search-set-filter "@10-weeks-ago +rust") "rust")
  ("T" (elfeed-search-set-filter "@1-day-ago") "Today")
  ("q" nil "quit" :color blue))

(use-package elfeed
  :init
  (progn
    (require 'elfeed)
    (require 'elfeed-org)
    (elfeed-org))
  (bind-key (kbd "C-x w") 'switch-to-elfeed-entry-buffer)
  :bind
  (:map elfeed-search-mode-map
	 ("?" . hydra-elfeed/body)
	 ("c" . hydra-elfeed/lambda-c)
	 ("l" . hydra-elfeed/lambda-l)
	 ("e" . hydra-elfeed/lambda-e)
	 ("t" . hydra-elfeed/lambda-t)
	 ("a" . hydra-elfeed/lambda-a)
	 ("s" . hydra-elfeed/lambda-s)
	 ("p" . hydra-elfeed/lambda-p)
	 ("r" . hydra-elfeed/lambda-r)
	 ("g" . elfeed-update))
  :config
  (setq-default elfeed-search-filter "@3-weeks-ago +clojure")
  (setf url-queue-timeout 30
	elfeed-show-switch-function #'elfeed-show-in-other-buffer
	elfeed-show-truncate-long-urls t
	elfeed-sort-order 'descending
	rmh-elfeed-org-files '("~/src/org/feeds.org")))
#+END_SRC
** dictionary
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle dictionary)
(use-package dictionary
  :bind (("C-x d" . dictionary-search)
	 ("C-x D" . dictionary-match-words))
  :config (load-library "dictionary-init"))
#+END_SRC
** engine-mode
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle engine-mode)
(setq browse-url-browser-function 'browse-url-generic
      browse-url-generic-program "firefox")
(use-package engine-mode
  :init
  (require 'engine-mode)
  (engine-mode)
  :config
  (engine/set-keymap-prefix (kbd "C-x /"))
  (defengine github
    "https://github.com/search?ref=simplesearch&q=%s"
    :browser 'browse-url-generic
    :keybinding "c")
  (defengine google
    "http://www.google.com/search?ie=utf-8&oe=utf-8&q=%s"
    :browser 'browse-url-generic
    :keybinding "g")
  (defengine duckduckgo
    "https://duckduckgo.com/?q=%s"
    :browser 'eww-browse-url
    :keybinding "d")
  (defengine wikipedia
    "http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"
    :keybinding "w"
    :browser 'browse-url-generic)
  (defengine youtube
    "http://www.youtube.com/results?aq=f&oq=&search_query=%s"
    :keybinding "y"
    :browser 'browse-url-generic))
#+END_SRC
** jabber
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle emacs-jabber)
(use-package jabber
  :config
  (setq
   jabber-auto-reconnect t
   jabber-vcard-avatars-retrieve nil
   jabber-avatar-verbose nil
   jabber-history-enabled t
   jabber-chat-buffer-format "*-jabber-%n-*"
   jabber-roster-buffer "*-jabber-*"
   jabber-roster-line-format " %c %-25n %u %-8s (%r)"
   jabber-show-offline-contacts nil)
  (add-hook 'jabber-mode-hook
            '(lambda ()
               (variable-pitch-mode 1)))
  :bind (("C-x C-j o" . jabber-chat-with)))

(defun jabber ()
  (interactive)
  (jabber-connect)
  (switch-to-buffer "*-jabber-*"))

(defun helm-jabber-online-contacts ()
  (with-no-warnings
    (cl-loop for item in (jabber-concat-rosters)
          when (get item 'connected)
          collect
          (if (get item 'name)
              (cons (get item 'name) item)
            (cons (symbol-name item) item)))))

(defvar helm-source-jabber-contacts
  (helm-build-sync-source "Jabber Contacts"
    :init (lambda () (require 'jabber))
    :candidates (lambda () (mapcar 'car (helm-jabber-online-contacts)))
    :action (lambda (x)
              (jabber-chat-with
               (jabber-read-account)
               (symbol-name
                (cdr (assoc x (helm-jabber-online-contacts))))))))
#+END_SRC
** slack
(el-get-bundle yuya373/emacs-slack)
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package slack
  :commands (slack-start)
  :init
  (setq slack-buffer-emojify nil
	slack-prefer-current-team t
	lui-prompt-string "=> "
	slack-buffer-function #'switch-to-buffer
	slack-prefer-current-team t
	slack-display-team-name nil))
(use-package alert
  :commands (alert)
  :init
  (setq alert-default-style 'notifier))
#+END_SRC
** erc
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle erc)
(el-get-bundle erc-extras)
(use-package erc
  :config
  (setq erc-auto-query 'frame
	erc-buffer-activity-timeout 0
	erc-hide-list '("JOIN" "PART" "QUIT")
	erc-track-exclude-types '("JOIN" "NICK" "PART" "QUIT")
	erc-track-position-in-mode-line t
	erc-kill-buffer-on-part t
	erc-fill-static-center 20
	erc-fill-function 'erc-fill-static
	erc-hide-list '("JOIN" "NICK" "PART" "QUIT")
	erc-max-buffer-size 30000
	erc-autojoin-channels-alist '(("freenode.net" "#emacs" "#clojure"))))

(defun irc ()
  (interactive)
  (erc :server "irc.freenode.net"
       :port 6667))
#+END_SRC
** restclient
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle restclient)
(use-package restclient
  :mode ("\\.http\\'" . restclient-mode))
#+END_SRC
** mu4e
#+BEGIN_SRC emacs-lisp :tangle yes
(el-get-bundle mu4e)
#+END_SRC
* secrets
** load-secrets
#+BEGIN_SRC emacs-lisp  :tangle yes
(defun load-if-exists (file)
  (when (file-exists-p file)
    (load-file file)))
(load-if-exists "~/.emacs.d/secret.el")
#+END_SRC

* quick-find
#+BEGIN_SRC emacs-lisp :tangle yes
(defun init ()
  (interactive)
  (find-file "~/.emacs.d/emacs-init.org"))
#+END_SRC
